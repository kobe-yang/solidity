# 自定义代币价格聚合器配置指南

## 目录

- [概述](#概述)
- [Chainlink 价格聚合器限制](#chainlink-价格聚合器限制)
- [Sepolia 测试网处理方案](#sepolia-测试网处理方案)
- [以太坊主网处理方案](#以太坊主网处理方案)
- [实际操作步骤](#实际操作步骤)
- [替代方案](#替代方案)
- [常见问题](#常见问题)

---

## 概述

Chainlink 价格聚合器主要支持**主流代币**（如 ETH、BTC、USDC、DAI 等）。对于**自定义代币**（如你自己部署的 ERC20 代币），通常没有 Chainlink 官方的价格聚合器。

本文档说明如何为自定义代币配置价格聚合器，区分 Sepolia 测试网和以太坊主网的不同处理方式。

### 快速决策流程

```
你的代币需要价格聚合器？
│
├─ 在 Sepolia 测试网？
│  └─ ✅ 使用 Mock 价格聚合器（推荐）
│
└─ 在以太坊主网？
   │
   ├─ 检查是否有 Chainlink 官方价格聚合器
   │  │
   │  ├─ ✅ 有 → 直接使用官方价格聚合器
   │  │
   │  └─ ❌ 没有 → 继续判断
   │     │
   │     ├─ 在 Uniswap V3 有流动性池？
   │     │  └─ ✅ 使用 Uniswap TWAP
   │     │
   │     ├─ 代币足够主流（高流动性、多交易所）？
   │     │  └─ ✅ 申请 Chainlink 官方支持
   │     │
   │     └─ 其他情况？
   │        └─ ✅ 使用第三方价格预言机或自定义价格源
```

### 检查清单

在开始之前，请确认：

- [ ] 你的代币是 ERC20 标准代币
- [ ] 已部署到目标网络（Sepolia 或主网）
- [ ] 已部署拍卖合约（NftAuctionWithOracle）
- [ ] 已获取目标网络的 RPC URL
- [ ] 已准备足够的 Gas 费用

---

## Chainlink 价格聚合器限制

### 支持的代币类型

Chainlink 官方提供价格聚合器的代币：

**主流代币：**
- ETH/USD
- BTC/USD
- USDC/USD
- DAI/USD
- LINK/USD
- 等（约 100+ 种主流代币）

**不支持：**
- ❌ 自定义部署的 ERC20 代币
- ❌ 新上线的小型代币
- ❌ 没有足够流动性的代币

### 为什么自定义代币没有价格聚合器？

1. **流动性要求**：Chainlink 需要代币有足够的交易量和流动性
2. **数据源**：需要多个交易所提供价格数据
3. **维护成本**：Chainlink 需要维护和更新价格数据
4. **市场需求**：只有主流代币有足够的需求

---

## Sepolia 测试网处理方案

### 方案 1：使用 Mock 价格聚合器（推荐用于测试）

地址：0xddd19C335D12b4F7613EA6D4cBBd8Ea0f61D3c7B

在测试网上，你可以部署一个 **Mock 价格聚合器**来模拟价格数据。
可以
#### 步骤 1：创建 Mock 价格聚合器合约

创建 `src/mocks/MockPriceFeed.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@chainlink/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * @title MockPriceFeed
 * @notice Mock 价格聚合器，用于测试
 * @dev 可以手动设置价格，模拟 Chainlink 价格聚合器
 */
contract MockPriceFeed is AggregatorV3Interface {
    int256 private _price;
    uint8 private _decimals = 8;
    string private _description;
    uint256 private _updatedAt;
    uint80 private _roundId;

    constructor(int256 initialPrice, string memory description) {
        _price = initialPrice;
        _description = description;
        _updatedAt = block.timestamp;
        _roundId = 1;
    }

    function decimals() external pure override returns (uint8) {
        return 8;
    }

    function description() external view override returns (string memory) {
        return _description;
    }

    function version() external pure override returns (uint256) {
        return 3;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (_roundId, _price, block.timestamp, _updatedAt, _roundId);
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (_roundId, _price, block.timestamp, _updatedAt, _roundId);
    }

    /**
     * @notice 更新价格（仅用于测试）
     * @param newPrice 新价格（8 位小数）
     */
    function updatePrice(int256 newPrice) external {
        _price = newPrice;
        _updatedAt = block.timestamp;
        _roundId++;
    }

    /**
     * @notice 获取当前价格
     */
    function getPrice() external view returns (int256) {
        return _price;
    }
}
```

#### 步骤 2：部署 Mock 价格聚合器

**方式 1：使用默认价格（$1.00）**

```bash
# 设置环境变量
export PRIVATE_KEY="0x你的私钥"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/YOUR_INFURA_ID"

# 部署 Mock 价格聚合器（默认价格 $1.00）
forge script script/DeployMockPriceFeed.s.sol:DeployMockPriceFeed \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
```

**方式 2：自定义初始价格**

```bash
# 设置自定义价格（例如：$2.50 = 250000000，8 位小数）
export INITIAL_PRICE="250000000"
export PRICE_DESCRIPTION="MyToken / USD"

forge script script/DeployMockPriceFeed.s.sol:DeployMockPriceFeed \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
```

**价格换算表：**
- $1.00 = 100000000 (8 位小数)
- $2.50 = 250000000
- $10.00 = 1000000000
- $100.00 = 10000000000

#### 步骤 3：在拍卖合约中设置价格聚合器

```bash
# 设置你的代币价格聚合器
cast send 0xYourAuctionContractAddress \
  "setTokenPriceFeed(address,address)" \
  0xYourTokenAddress \
  0xMockPriceFeedAddress \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY
```

### 方案 2：使用 ETH 价格作为参考（简单方案）

如果你的代币在测试网上没有实际价值，可以使用 ETH 价格作为参考：

```solidity
// 假设 1 个你的代币 = 0.001 ETH
// 在合约中设置一个固定比例
uint256 constant TOKEN_TO_ETH_RATIO = 0.001 ether; // 1 token = 0.001 ETH

function getTokenPriceInUSD(address token) public view returns (uint256) {
    if (token == yourTokenAddress) {
        uint256 ethPrice = getEthPriceInUSD();
        // 1 token = 0.001 ETH = 0.001 * ETH_PRICE USD
        return (TOKEN_TO_ETH_RATIO * ethPrice) / 1e18;
    }
    // 其他代币使用 Chainlink 价格聚合器
    return tokenPriceFeeds[token].getPriceInUSD(stalePriceThreshold);
}
```

### 方案 3：使用 Chainlink Data Feeds Registry（如果可用）

Chainlink 提供了 Data Feeds Registry，可以查询是否有价格聚合器：

```solidity
import "@chainlink/src/v0.8/shared/interfaces/FeedRegistryInterface.sol";

// Sepolia Registry: 0x86E53CF1B870786351Da77A57575e79CB55812CB
FeedRegistryInterface registry = FeedRegistryInterface(0x86E53CF1B870786351Da77A57575e79CB55812CB);

// 查询是否有价格聚合器
try registry.getFeed(token, Denominations.USD) returns (AggregatorV3Interface priceFeed) {
    // 有价格聚合器，使用它
    return priceFeed.getPriceInUSD(stalePriceThreshold);
} catch {
    // 没有价格聚合器，使用替代方案
}
```

---

## 以太坊主网处理方案

### 方案 1：申请 Chainlink 价格聚合器（长期方案）

如果你的代币在主网上有足够的流动性和交易量，可以申请 Chainlink 官方支持：

**申请流程：**
1. 访问 [Chainlink Data Feeds](https://data.chain.link/)
2. 查看是否已有价格聚合器
3. 如果没有，联系 Chainlink 团队申请
4. 提供代币信息、交易量、流动性证明等

**要求：**
- 代币有足够的交易量和流动性
- 在多个主流交易所上市
- 有稳定的交易对（如 TOKEN/USD 或 TOKEN/ETH）

### 方案 2：使用第三方价格预言机

如果 Chainlink 不支持，可以使用其他价格预言机：

**选项：**
1. **Uniswap V3 TWAP**：使用 Uniswap 池的时间加权平均价格
2. **Band Protocol**：去中心化价格预言机
3. **API3**：去中心化 API 服务
4. **自定义价格源**：自己维护价格数据

### 方案 3：使用 Uniswap V3 TWAP（推荐）

Uniswap V3 提供了时间加权平均价格（TWAP），可以用于获取代币价格：

```solidity
import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

/**
 * @notice 使用 Uniswap V3 TWAP 获取代币价格
 * @param pool Uniswap V3 池地址
 * @param twapInterval TWAP 时间间隔（秒）
 */
function getTokenPriceFromUniswap(
    address pool,
    uint32 twapInterval
) public view returns (uint256 price) {
    IUniswapV3Pool uniswapPool = IUniswapV3Pool(pool);
    
    // 获取 TWAP
    (int24 tick, ) = OracleLibrary.consult(
        address(uniswapPool),
        twapInterval
    );
    
    // 将 tick 转换为价格
    price = OracleLibrary.getQuoteAtTick(
        tick,
        uint128(1e18), // 1 token
        address(token0),
        address(token1)
    );
    
    return price;
}
```

**前提条件：**
- 代币在 Uniswap V3 上有流动性池
- 池子有足够的流动性

### 方案 4：创建自定义价格源（高级方案）

如果以上方案都不适用，可以创建自己的价格源：

1. **部署价格更新合约**：允许可信节点更新价格
2. **使用多重签名**：多个节点共同维护价格
3. **集成多个数据源**：聚合多个交易所的价格

---

## 快速开始

### Sepolia 测试网：3 步配置自定义代币价格

```bash
# 步骤 1: 部署 Mock 价格聚合器
forge script script/DeployMockPriceFeed.s.sol:DeployMockPriceFeed \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast

# 步骤 2: 在拍卖合约中设置价格聚合器
cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $YOUR_TOKEN \
  $MOCK_PRICE_FEED \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 步骤 3: 验证配置
cast call $AUCTION_CONTRACT \
  "getTokenPriceInUSD(address)(uint256)" \
  $YOUR_TOKEN \
  --rpc-url $SEPOLIA_RPC_URL
```

### 以太坊主网：检查官方价格聚合器

```bash
# 步骤 1: 检查是否有官方价格聚合器
# 访问 https://data.chain.link/ 搜索你的代币

# 步骤 2: 如果有，直接设置
cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $YOUR_TOKEN \
  $OFFICIAL_PRICE_FEED \
  --rpc-url $MAINNET_RPC_URL \
  --private-key $PRIVATE_KEY

# 步骤 3: 如果没有，使用替代方案（见下文）
```

---

## 实际操作步骤

### Sepolia 测试网：使用 Mock 价格聚合器

#### 步骤 1：创建 Mock 价格聚合器部署脚本

创建 `script/DeployMockPriceFeed.s.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/mocks/MockPriceFeed.sol";

contract DeployMockPriceFeed is Script {
    function run() external returns (MockPriceFeed) {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        
        // 设置初始价格：$1.00 = 100000000 (8 位小数)
        int256 initialPrice = 100000000;
        string memory description = "YourToken / USD";
        
        vm.startBroadcast(deployerPrivateKey);
        
        MockPriceFeed mockFeed = new MockPriceFeed(initialPrice, description);
        
        vm.stopBroadcast();
        
        console2.log("MockPriceFeed deployed at:", address(mockFeed));
        console2.log("Initial price:", initialPrice);
        
        return mockFeed;
    }
}
```

#### 步骤 2：部署 Mock 价格聚合器

```bash
# 设置环境变量
export PRIVATE_KEY="0x你的私钥"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/YOUR_INFURA_ID"

# 部署 Mock 价格聚合器
forge script script/DeployMockPriceFeed.s.sol:DeployMockPriceFeed \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
```

#### 步骤 3：在拍卖合约中设置价格聚合器

```bash
# 设置你的代币价格聚合器
export AUCTION_CONTRACT="0x你的拍卖合约地址"
export YOUR_TOKEN="0x你的代币地址"
export MOCK_PRICE_FEED="0xMock价格聚合器地址"

cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $YOUR_TOKEN \
  $MOCK_PRICE_FEED \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY
```

#### 步骤 4：验证设置

```bash
# 查询代币价格（返回 18 位小数，例如：1000000000000000000000 = $1.00）
cast call $AUCTION_CONTRACT \
  "getTokenPriceInUSD(address)(uint256)" \
  $YOUR_TOKEN \
  --rpc-url $SEPOLIA_RPC_URL

# 查询 Mock 价格聚合器的当前价格
cast call $MOCK_PRICE_FEED \
  "getPrice()(int256)" \
  --rpc-url $SEPOLIA_RPC_URL
```

#### 步骤 5：更新价格（测试用）

```bash
# 更新价格为 $2.00（200000000，8 位小数）
cast send $MOCK_PRICE_FEED \
  "updatePrice(int256)" \
  200000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 验证价格已更新
cast call $MOCK_PRICE_FEED \
  "getPrice()(int256)" \
  --rpc-url $SEPOLIA_RPC_URL
```

### 以太坊主网：检查和使用官方价格聚合器

#### 步骤 1：检查是否有官方价格聚合器

访问 [Chainlink Data Feeds](https://data.chain.link/) 或使用以下方法：

```bash
# 使用 Chainlink Data Feeds Registry 查询
# 主网 Registry: 0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf

# 或者直接查看 Chainlink 文档
# https://docs.chain.link/data-feeds/price-feeds/addresses
```

#### 步骤 2：如果有官方价格聚合器

```bash
# 直接设置官方价格聚合器地址
cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $YOUR_TOKEN \
  0xOfficialPriceFeedAddress \
  --rpc-url $MAINNET_RPC_URL \
  --private-key $PRIVATE_KEY
```

#### 步骤 3：如果没有官方价格聚合器

使用替代方案（Uniswap TWAP 或第三方预言机）。

---

## 替代方案对比

| 方案 | Sepolia 测试网 | 以太坊主网 | 优点 | 缺点 |
|------|---------------|-----------|------|------|
| **Mock 价格聚合器** | ✅ 推荐 | ❌ 不适用 | 简单、可控 | 仅用于测试 |
| **Chainlink 官方** | ✅ 可用 | ✅ 可用 | 可靠、去中心化 | 只支持主流代币 |
| **Uniswap TWAP** | ✅ 可用 | ✅ 推荐 | 去中心化、实时 | 需要流动性池 |
| **第三方预言机** | ⚠️ 可能不支持 | ✅ 可用 | 灵活 | 需要额外信任 |
| **自定义价格源** | ✅ 可用 | ✅ 可用 | 完全控制 | 复杂、需要维护 |

---

## 常见问题

### Q1: 如何知道我的代币是否有 Chainlink 价格聚合器？

**方法 1：查看 Chainlink 文档**
- 访问 [Chainlink Data Feeds](https://data.chain.link/)
- 搜索你的代币符号

**方法 2：使用 Data Feeds Registry**
```solidity
FeedRegistryInterface registry = FeedRegistryInterface(0x...);
try registry.getFeed(token, Denominations.USD) returns (AggregatorV3Interface) {
    // 有价格聚合器
} catch {
    // 没有价格聚合器
}
```

**方法 3：查看价格聚合器地址列表**
- Sepolia: https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1
- Mainnet: https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1

### Q2: Mock 价格聚合器可以用于主网吗？

**不建议！** Mock 价格聚合器只应该用于测试网，因为：
- 价格可以被人为操控
- 没有真实的价格数据源
- 不适合生产环境

### Q3: 如何更新 Mock 价格聚合器的价格？

```bash
# 更新价格（仅用于测试）
cast send 0xMockPriceFeedAddress \
  "updatePrice(int256)" \
  200000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 200000000 = $2.00 (8 位小数)
```

### Q4: 如果我的代币在主网上没有价格聚合器怎么办？

**推荐方案：**
1. 使用 Uniswap V3 TWAP（如果有流动性池）
2. 申请 Chainlink 官方支持（如果代币足够主流）
3. 使用第三方价格预言机（Band Protocol、API3 等）
4. 创建自定义价格源（需要技术团队维护）

### Q5: 如何为代币设置固定价格（测试用）？

可以在合约中添加固定价格映射：

```solidity
mapping(address => uint256) public fixedPrices; // 代币 => 固定价格（18 位小数）

function setFixedPrice(address token, uint256 price) external onlyOwner {
    fixedPrices[token] = price;
}

function getTokenPriceInUSD(address token) public view returns (uint256) {
    // 优先使用固定价格
    if (fixedPrices[token] > 0) {
        return fixedPrices[token];
    }
    // 否则使用价格聚合器
    return tokenPriceFeeds[token].getPriceInUSD(stalePriceThreshold);
}
```

---

## 完整示例：为 SimpleNFT 代币配置价格

假设你有一个名为 `SimpleNFT` 的 ERC20 代币，需要为其配置价格聚合器。

### Sepolia 测试网完整流程

```bash
# ============ 步骤 1: 部署 Mock 价格聚合器 ============
export PRIVATE_KEY="0x你的私钥"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/YOUR_INFURA_ID"

# 设置代币价格为 $1.50
export INITIAL_PRICE="150000000"  # $1.50 (8 位小数)
export PRICE_DESCRIPTION="SimpleNFT / USD"

# 部署
forge script script/DeployMockPriceFeed.s.sol:DeployMockPriceFeed \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv

# 记录部署的地址（从输出中获取）
export MOCK_PRICE_FEED="0xMockPriceFeedAddress"

# ============ 步骤 2: 部署拍卖合约 ============
# （如果还没有部署）
forge script script/DeployNftAuctionWithOracle.s.sol:DeployNftAuctionWithOracle \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv

# 记录拍卖合约地址
export AUCTION_CONTRACT="0xAuctionContractAddress"

# ============ 步骤 3: 设置 SimpleNFT 代币价格聚合器 ============
export SIMPLE_NFT_TOKEN="0xYourSimpleNFTTokenAddress"

cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $SIMPLE_NFT_TOKEN \
  $MOCK_PRICE_FEED \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# ============ 步骤 4: 验证配置 ============
# 查询 SimpleNFT 的美元价格
cast call $AUCTION_CONTRACT \
  "getTokenPriceInUSD(address)(uint256)" \
  $SIMPLE_NFT_TOKEN \
  --rpc-url $SEPOLIA_RPC_URL

# 预期输出：1500000000000000000000 (表示 $1.50，18 位小数)

# ============ 步骤 5: 测试使用代币出价 ============
# 假设你有一个拍卖 ID = 1，起拍价 $1000
# 出价 1000 SimpleNFT 代币（假设 18 位小数）

# 先授权代币
cast send $SIMPLE_NFT_TOKEN \
  "approve(address,uint256)" \
  $AUCTION_CONTRACT \
  1000000000000000000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# 使用 SimpleNFT 代币出价
cast send $AUCTION_CONTRACT \
  "bidWithERC20(uint256,address,uint256)" \
  1 \
  $SIMPLE_NFT_TOKEN \
  1000000000000000000000 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY

# ============ 步骤 6: 查询拍卖的美元价值 ============
# 查询当前最高出价的美元价值
cast call $AUCTION_CONTRACT \
  "getAuctionHighestBidUSD(uint256)(uint256)" \
  1 \
  --rpc-url $SEPOLIA_RPC_URL

# 预期输出：1500000000000000000000 (表示 $1500，因为 1000 tokens × $1.50 = $1500)
```

### 以太坊主网完整流程

```bash
# ============ 步骤 1: 检查是否有官方价格聚合器 ============
# 访问 https://data.chain.link/ 搜索 "SimpleNFT" 或你的代币符号
# 或者查看：https://docs.chain.link/data-feeds/price-feeds/addresses

# ============ 情况 A: 有官方价格聚合器 ============
export OFFICIAL_PRICE_FEED="0xOfficialPriceFeedAddress"
export SIMPLE_NFT_TOKEN="0xYourSimpleNFTTokenAddress"
export AUCTION_CONTRACT="0xAuctionContractAddress"

# 直接设置官方价格聚合器
cast send $AUCTION_CONTRACT \
  "setTokenPriceFeed(address,address)" \
  $SIMPLE_NFT_TOKEN \
  $OFFICIAL_PRICE_FEED \
  --rpc-url $MAINNET_RPC_URL \
  --private-key $PRIVATE_KEY

# ============ 情况 B: 没有官方价格聚合器 ============
# 选项 1: 使用 Uniswap V3 TWAP（如果有流动性池）
# 选项 2: 使用第三方价格预言机
# 选项 3: 申请 Chainlink 官方支持
```

---

## 总结

### Sepolia 测试网
- ✅ **推荐**：使用 Mock 价格聚合器
- ✅ **简单**：部署 Mock 合约，设置固定价格
- ✅ **灵活**：可以随时更新价格进行测试

### 以太坊主网
- ✅ **首选**：检查是否有 Chainlink 官方价格聚合器
- ✅ **备选**：使用 Uniswap V3 TWAP（如果有流动性池）
- ⚠️ **最后**：使用第三方预言机或创建自定义价格源

### 最佳实践
1. **测试网**：使用 Mock 价格聚合器，快速测试
2. **主网**：优先使用 Chainlink 官方价格聚合器
3. **自定义代币**：如果足够主流，申请 Chainlink 支持
4. **小币种**：使用 Uniswap TWAP 或其他去中心化方案

---

## 相关资源

- [Chainlink Data Feeds 文档](https://docs.chain.link/data-feeds)
- [Chainlink 价格聚合器地址列表](https://docs.chain.link/data-feeds/price-feeds/addresses)
- [Uniswap V3 Oracle 文档](https://docs.uniswap.org/contracts/v3/guides/flash-swaps/oracle-integration)
- [Band Protocol 文档](https://docs.bandchain.org/)

