# Chainlink 价格预言机实现

## 目录

- [概述](#概述)
- [价格聚合器详解](#价格聚合器详解)
- [两种实现方式对比](#两种实现方式对比)
- [实现步骤](#实现步骤)
- [为什么这样实现](#为什么这样实现)
- [完整代码](#完整代码)
- [使用示例](#使用示例)
- [常见价格聚合器地址](#常见价格聚合器地址)
- [注意事项](#注意事项)

---

## 概述

Chainlink 价格预言机允许智能合约获取链下资产（如 ETH、ERC20 代币）的实时美元价格。这对于需要价格信息的 DeFi 应用（如借贷、交易、拍卖等）至关重要。

### 核心概念

1. **AggregatorV3Interface**：Chainlink 提供的标准接口，用于访问价格数据
2. **价格聚合器（Price Feed）**：Chainlink 维护的链上合约，定期更新价格数据
3. **价格精度**：Chainlink 价格通常以 8 位小数表示（例如：$3000.50 = 300050000000）

---

## 价格聚合器详解

### 什么是价格聚合器（Price Aggregator）？

**价格聚合器**（也称为 Price Feed）是 Chainlink 部署在区块链上的智能合约，它存储并定期更新各种资产（如 ETH、BTC、USDC 等）相对于美元（或其他基础货币）的实时价格。

### 价格聚合器的作用

#### 1. **桥接链下数据到链上**

区块链是封闭的系统，无法直接访问链下的价格数据（如 Coinbase、Binance 等交易所的价格）。价格聚合器解决了这个问题：

```
链下交易所价格 → Chainlink 节点 → 价格聚合器合约 → 你的智能合约
```

**示例流程：**
1. Chainlink 节点从多个交易所（Coinbase、Binance、Kraken 等）获取 ETH/USD 价格
2. 节点对价格进行聚合计算（去除异常值，计算中位数等）
3. 节点将聚合后的价格更新到链上的价格聚合器合约
4. 你的智能合约从价格聚合器读取价格

#### 2. **提供可靠的价格数据**

价格聚合器通过以下机制确保数据可靠性：

- **多数据源聚合**：从多个交易所获取价格，避免单一数据源的风险
- **去中心化节点网络**：多个 Chainlink 节点独立获取和验证价格
- **异常值过滤**：自动过滤异常价格，防止市场操纵
- **定期更新**：价格通常每小时或更频繁地更新

#### 3. **标准化接口**

所有价格聚合器都实现 `AggregatorV3Interface` 接口，提供统一的数据访问方式：

```solidity
interface AggregatorV3Interface {
    // 获取最新价格数据
    function latestRoundData() external view returns (
        uint80 roundId,      // 轮次 ID
        int256 answer,       // 价格（8 位小数）
        uint256 startedAt,   // 开始时间
        uint256 updatedAt,   // 更新时间
        uint80 answeredInRound // 回答的轮次
    );
    
    // 获取精度（通常是 8）
    function decimals() external view returns (uint8);
    
    // 获取描述（如 "ETH / USD"）
    function description() external view returns (string memory);
}
```

### 价格聚合器的工作原理

#### 架构图

```
┌─────────────────────────────────────────────────────────┐
│                    链下数据源                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐               │
│  │ Coinbase │  │ Binance  │  │ Kraken   │  ...          │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘               │
└───────┼─────────────┼─────────────┼──────────────────────┘
        │             │             │
        └─────────────┴─────────────┘
                    │
        ┌───────────▼───────────┐
        │   Chainlink 节点网络   │
        │  - 获取价格            │
        │  - 聚合计算            │
        │  - 验证数据            │
        └───────────┬───────────┘
                    │
        ┌───────────▼───────────┐
        │   价格聚合器合约        │
        │  (链上智能合约)         │
        │  地址: 0x5f4eC3...    │
        └───────────┬───────────┘
                    │
        ┌───────────▼───────────┐
        │   你的智能合约          │
        │  (PriceOracle)        │
        └───────────────────────┘
```

#### 数据更新流程

1. **数据收集阶段**
   - Chainlink 节点从多个交易所 API 获取价格
   - 每个节点独立获取数据，互不干扰

2. **数据聚合阶段**
   - 节点对收集到的价格进行统计处理：
     - 去除最高和最低的异常值
     - 计算中位数或加权平均
     - 确保数据质量

3. **链上更新阶段**
   - 节点将聚合后的价格提交到价格聚合器合约
   - 合约验证数据并更新存储
   - 记录更新时间戳和轮次 ID

4. **数据查询阶段**
   - 你的智能合约调用 `latestRoundData()`
   - 价格聚合器返回最新的价格数据
   - 你的合约验证数据有效性后使用

### 为什么需要价格聚合器？

#### 问题 1：区块链无法访问链下数据

**问题：**
```solidity
// ❌ 这不可能实现
uint256 ethPrice = getPriceFromCoinbase(); // 区块链无法直接调用外部 API
```

**解决方案：**
```solidity
// ✅ 使用价格聚合器
AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3...);
(, int256 price, , , ) = priceFeed.latestRoundData();
```

#### 问题 2：单一数据源不可靠

**问题：**
- 如果只从一个交易所获取价格，该交易所可能：
  - 被攻击或故障
  - 价格被操纵
  - 数据延迟或错误

**解决方案：**
- 价格聚合器从多个交易所聚合数据
- 自动过滤异常值
- 多个节点独立验证

#### 问题 3：价格数据需要标准化

**问题：**
- 不同交易所的价格格式不同
- 时间戳、精度不统一
- 难以在智能合约中使用

**解决方案：**
- 价格聚合器提供标准化的接口
- 统一的数据格式（8 位小数）
- 标准化的时间戳和轮次 ID

### 价格聚合器的实际应用场景

#### 1. **DeFi 借贷协议**

```solidity
// 计算抵押品的美元价值
function calculateCollateralValue(uint256 ethAmount) public view returns (uint256) {
    uint256 ethPrice = oracle.getEthPriceInUSD();
    return (ethAmount * ethPrice) / 1e18;
}

// 检查是否满足抵押率要求
function canBorrow(uint256 collateral, uint256 debt) public view returns (bool) {
    uint256 collateralValue = calculateCollateralValue(collateral);
    uint256 debtValue = calculateDebtValue(debt);
    return collateralValue * 100 >= debtValue * 150; // 150% 抵押率
}
```

#### 2. **NFT 拍卖**

```solidity
// 将 ETH 出价转换为美元价值显示
function getAuctionValueInUSD(uint256 auctionId) public view returns (uint256) {
    Auction memory auction = auctions[auctionId];
    return oracle.ethToUSD(auction.highestBid);
}
```

#### 3. **代币兑换**

```solidity
// 计算代币兑换比例
function getExchangeRate(address tokenA, address tokenB) public view returns (uint256) {
    uint256 priceA = oracle.getTokenPriceInUSD(tokenA);
    uint256 priceB = oracle.getTokenPriceInUSD(tokenB);
    return (priceA * 1e18) / priceB;
}
```

### 价格聚合器的数据格式

#### 价格存储格式

Chainlink 价格以 **8 位小数**存储：

```
实际价格: $3,000.50
存储格式: 300050000000 (8 位小数)
          = 3000.50 * 10^8
```

#### 返回数据结构

```solidity
struct PriceData {
    uint80 roundId;           // 轮次 ID（递增）
    int256 answer;            // 价格（8 位小数）
    uint256 startedAt;        // 轮次开始时间
    uint256 updatedAt;        // 价格更新时间
    uint80 answeredInRound;   // 回答的轮次 ID
}
```

#### 数据验证

```solidity
// 验证价格数据有效性
require(price > 0, "Invalid price");
require(updatedAt > 0, "Price feed not updated");
require(answeredInRound >= roundId, "Stale price");
require(block.timestamp - updatedAt <= staleThreshold, "Price too stale");
```

### 价格聚合器的优势

| 优势 | 说明 |
|------|------|
| **可靠性** | 多数据源聚合，去中心化节点网络 |
| **准确性** | 自动过滤异常值，统计聚合 |
| **实时性** | 定期更新（通常每小时或更频繁） |
| **标准化** | 统一的接口和数据格式 |
| **安全性** | 经过充分测试和审计 |
| **易用性** | 简单的接口调用即可获取价格 |

### 总结

**价格聚合器是 Chainlink 预言机的核心组件**，它：

1. ✅ **桥接链下和链上**：将链下交易所的价格数据带到区块链上
2. ✅ **提供可靠数据**：通过多数据源聚合确保价格准确性
3. ✅ **标准化接口**：提供统一的数据访问方式
4. ✅ **广泛应用**：支持 DeFi、NFT、交易等各种场景

**简单来说，价格聚合器就是区块链上的"价格数据库"，你的智能合约可以随时查询各种资产的实时价格！**

---

## 两种实现方式对比

本项目提供了两种实现方式，你可以根据需求选择：

### 方式 1：自定义接口实现（PriceOracle.sol）

**特点：**
- ✅ 不依赖外部库，代码更轻量
- ✅ 自己定义 `AggregatorV3Interface` 接口
- ✅ 适合不想安装额外库的项目
- ⚠️ 需要手动维护接口定义

**导入方式：**
```solidity
// 自己定义的接口
interface AggregatorV3Interface {
    function latestRoundData() external view returns (...);
}
```

**文件位置：** `src/PriceOracle.sol`

---

### 方式 2：使用官方库（PriceOracleOfficial.sol）⭐ 推荐

**特点：**
- ✅ 使用 Chainlink 官方维护的库
- ✅ 自动获得库的更新和修复
- ✅ 更可靠，经过充分测试
- ✅ 可以使用官方接口的额外功能（如 `decimals()`, `description()`, `version()`）
- ⚠️ 需要安装 `chainlink-brownie-contracts` 库

**导入方式：**
```solidity
import "@chainlink/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
```

**文件位置：** `src/PriceOracleOfficial.sol`

**额外功能：**
```solidity
// 获取价格聚合器的详细信息
function getPriceFeedInfo(AggregatorV3Interface priceFeed)
    public view returns (uint8 decimals, string memory description, uint256 version)

// 获取 ETH 价格聚合器信息
function getEthPriceFeedInfo() public view returns (...)
```

---

### 对比表格

| 特性 | PriceOracle.sol | PriceOracleOfficial.sol |
|------|----------------|------------------------|
| 依赖库 | 无 | chainlink-brownie-contracts |
| 接口来源 | 自定义 | 官方库 |
| 代码量 | 较小 | 稍大（但功能更全） |
| 维护性 | 需手动维护 | 自动更新 |
| 额外功能 | 基础功能 | 支持 `decimals()`, `description()` 等 |
| 推荐度 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

---

### 如何选择？

- **推荐使用 `PriceOracleOfficial.sol`**：如果你已经安装了 Chainlink 库，或者需要更可靠、功能更全的实现
- **使用 `PriceOracle.sol`**：如果你的项目不想引入额外依赖，或者只需要基础功能

**注意：** 两种实现的功能基本相同，核心逻辑一致，只是接口来源不同。

---

## 实现步骤

### 步骤 1：安装 Chainlink 合约库

```bash
# 在 Foundry 项目中安装 Chainlink 合约
forge install smartcontractkit/chainlink-brownie-contracts --no-commit
```

或者使用 npm（如果使用 Hardhat）：

```bash
npm install @chainlink/contracts
```

### 步骤 2：配置 remappings

在 `foundry.toml` 中添加 Chainlink 的路径映射：

```toml
remappings = [
    "openzeppelin/=lib/openzeppelin-contracts/",
    "forge-std/=lib/forge-std/src/",
    "@chainlink/=lib/chainlink-brownie-contracts/contracts/"
]
```

### 步骤 3：导入接口

```solidity
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
```

### 步骤 4：定义价格聚合器变量

```solidity
AggregatorV3Interface internal ethUsdPriceFeed;
mapping(address => AggregatorV3Interface) public tokenPriceFeeds;
```

### 步骤 5：实现价格查询函数

使用 `latestRoundData()` 获取最新价格数据：

```solidity
function getLatestPrice(AggregatorV3Interface priceFeed) 
    internal 
    view 
    returns (int256) 
{
    (
        uint80 roundId,
        int256 price,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    ) = priceFeed.latestRoundData();
    
    require(price > 0, "Invalid price");
    require(updatedAt > 0, "Price feed not updated");
    
    return price;
}
```

### 步骤 6：处理价格精度转换

Chainlink 价格以 8 位小数存储，需要转换为可读格式：

```solidity
function getPriceInUSD(AggregatorV3Interface priceFeed) 
    public 
    view 
    returns (uint256) 
{
    int256 price = getLatestPrice(priceFeed);
    // 转换为 18 位小数（Wei 精度）
    return uint256(price) * 1e10; // 1e18 / 1e8 = 1e10
}
```

---

## 为什么这样实现

### 1. 为什么使用 AggregatorV3Interface？

**原因：**
- **标准化接口**：Chainlink 提供的标准接口，确保兼容性
- **版本稳定**：V3 接口是当前稳定版本，广泛使用
- **数据完整性**：返回多个字段（roundId、价格、时间戳等），便于验证数据有效性

**优势：**
- 无需了解底层实现细节
- 接口向后兼容
- 支持多链部署

### 2. 为什么需要检查价格有效性？

```solidity
require(price > 0, "Invalid price");
require(updatedAt > 0, "Price feed not updated");
```

**原因：**
- **防止零价格攻击**：如果价格为 0，可能导致计算错误
- **数据新鲜度**：确保价格数据是最新的，避免使用过时数据
- **安全性**：防止预言机故障导致的资金损失

### 3. 为什么需要精度转换？

Chainlink 价格以 **8 位小数**存储，而 Solidity 中 ETH 以 **18 位小数**（Wei）表示。

**示例：**
- Chainlink: $3000.50 = `300050000000` (8 位小数)
- 转换为 Wei 精度: `300050000000 * 1e10 = 3000500000000000000000` (18 位小数)

**为什么这样设计：**
- **统一精度**：便于在合约中进行价格计算
- **避免精度丢失**：使用整数运算，避免浮点数精度问题
- **兼容性**：与 ERC20 代币的 18 位小数标准一致

### 4. 为什么使用 mapping 存储多个代币价格？

```solidity
mapping(address => AggregatorV3Interface) public tokenPriceFeeds;
```

**原因：**
- **灵活性**：支持查询多种 ERC20 代币价格
- **可扩展性**：可以动态添加新的代币价格源
- **Gas 效率**：按需查询，不存储不使用的价格源

### 5. 为什么需要时间戳检查？

```solidity
require(block.timestamp - updatedAt < stalePriceThreshold, "Price too stale");
```

**原因：**
- **数据新鲜度**：确保价格数据不会太旧
- **防止攻击**：如果预言机停止更新，旧价格可能被利用
- **最佳实践**：Chainlink 推荐检查价格更新时间

---

## 完整代码

### PriceOracle.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "openzeppelin/contracts/access/Ownable.sol";

/**
 * @title PriceOracle
 * @notice 使用 Chainlink 价格预言机获取 ETH 和 ERC20 代币的美元价格
 */
contract PriceOracle is Ownable {
    // ETH/USD 价格聚合器
    AggregatorV3Interface public ethUsdPriceFeed;
    
    // ERC20 代币地址 => 价格聚合器
    mapping(address => AggregatorV3Interface) public tokenPriceFeeds;
    
    // 价格过期时间阈值（秒）
    uint256 public stalePriceThreshold = 3600; // 1 小时
    
    event PriceFeedUpdated(address indexed token, address indexed priceFeed);
    event StalePriceThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);

    /**
     * @notice 构造函数
     * @param _ethUsdPriceFeed ETH/USD 价格聚合器地址
     */
    constructor(address _ethUsdPriceFeed) Ownable(msg.sender) {
        require(_ethUsdPriceFeed != address(0), "Invalid price feed address");
        ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);
    }

    /**
     * @notice 设置 ERC20 代币的价格聚合器
     * @param token ERC20 代币地址
     * @param priceFeed 价格聚合器地址
     */
    function setTokenPriceFeed(address token, address priceFeed) external onlyOwner {
        require(token != address(0), "Invalid token address");
        require(priceFeed != address(0), "Invalid price feed address");
        tokenPriceFeeds[token] = AggregatorV3Interface(priceFeed);
        emit PriceFeedUpdated(token, priceFeed);
    }

    /**
     * @notice 设置价格过期时间阈值
     * @param _threshold 新的阈值（秒）
     */
    function setStalePriceThreshold(uint256 _threshold) external onlyOwner {
        uint256 oldThreshold = stalePriceThreshold;
        stalePriceThreshold = _threshold;
        emit StalePriceThresholdUpdated(oldThreshold, _threshold);
    }

    /**
     * @notice 获取价格数据（内部函数）
     * @param priceFeed 价格聚合器接口
     * @return price 价格（8 位小数）
     * @return updatedAt 更新时间戳
     */
    function _getPriceData(AggregatorV3Interface priceFeed)
        internal
        view
        returns (int256 price, uint256 updatedAt)
    {
        require(address(priceFeed) != address(0), "Price feed not set");
        
        (
            uint80 roundId,
            int256 rawPrice,
            uint256 startedAt,
            uint256 rawUpdatedAt,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();

        require(rawPrice > 0, "Invalid price");
        require(rawUpdatedAt > 0, "Price feed not updated");
        require(answeredInRound >= roundId, "Stale price");

        // 检查价格是否过期
        require(
            block.timestamp - rawUpdatedAt <= stalePriceThreshold,
            "Price too stale"
        );

        return (rawPrice, rawUpdatedAt);
    }

    /**
     * @notice 获取 ETH 的美元价格（8 位小数）
     * @return price ETH 价格（例如：$3000.50 = 300050000000）
     */
    function getEthPrice() public view returns (int256) {
        (int256 price, ) = _getPriceData(ethUsdPriceFeed);
        return price;
    }

    /**
     * @notice 获取 ETH 的美元价格（18 位小数，Wei 精度）
     * @return price ETH 价格，精度为 1e18
     */
    function getEthPriceInUSD() public view returns (uint256) {
        (int256 price, ) = _getPriceData(ethUsdPriceFeed);
        // 从 8 位小数转换为 18 位小数
        return uint256(price) * 1e10;
    }

    /**
     * @notice 获取 ERC20 代币的美元价格（8 位小数）
     * @param token ERC20 代币地址
     * @return price 代币价格
     */
    function getTokenPrice(address token) public view returns (int256) {
        AggregatorV3Interface priceFeed = tokenPriceFeeds[token];
        require(address(priceFeed) != address(0), "Token price feed not set");
        (int256 price, ) = _getPriceData(priceFeed);
        return price;
    }

    /**
     * @notice 获取 ERC20 代币的美元价格（18 位小数）
     * @param token ERC20 代币地址
     * @return price 代币价格，精度为 1e18
     */
    function getTokenPriceInUSD(address token) public view returns (uint256) {
        (int256 price, ) = _getPriceData(tokenPriceFeeds[token]);
        return uint256(price) * 1e10;
    }

    /**
     * @notice 获取 ETH 和代币的价格信息（包含更新时间）
     * @param token ERC20 代币地址（可选，address(0) 表示只查询 ETH）
     * @return ethPrice ETH 价格（18 位小数）
     * @return tokenPrice 代币价格（18 位小数，如果 token 为 address(0) 则返回 0）
     * @return ethUpdatedAt ETH 价格更新时间
     * @return tokenUpdatedAt 代币价格更新时间
     */
    function getPrices(address token)
        public
        view
        returns (
            uint256 ethPrice,
            uint256 tokenPrice,
            uint256 ethUpdatedAt,
            uint256 tokenUpdatedAt
        )
    {
        (int256 ethPriceRaw, uint256 ethUpdated) = _getPriceData(ethUsdPriceFeed);
        ethPrice = uint256(ethPriceRaw) * 1e10;
        ethUpdatedAt = ethUpdated;

        if (token != address(0)) {
            AggregatorV3Interface tokenFeed = tokenPriceFeeds[token];
            require(address(tokenFeed) != address(0), "Token price feed not set");
            (int256 tokenPriceRaw, uint256 tokenUpdated) = _getPriceData(tokenFeed);
            tokenPrice = uint256(tokenPriceRaw) * 1e10;
            tokenUpdatedAt = tokenUpdated;
        }
    }

    /**
     * @notice 将 ETH 数量转换为美元价值
     * @param ethAmount ETH 数量（Wei，18 位小数）
     * @return usdValue 美元价值（18 位小数）
     */
    function ethToUSD(uint256 ethAmount) public view returns (uint256) {
        uint256 ethPrice = getEthPriceInUSD();
        return (ethAmount * ethPrice) / 1e18;
    }

    /**
     * @notice 将代币数量转换为美元价值
     * @param token ERC20 代币地址
     * @param tokenAmount 代币数量（假设 18 位小数）
     * @return usdValue 美元价值（18 位小数）
     */
    function tokenToUSD(address token, uint256 tokenAmount)
        public
        view
        returns (uint256)
    {
        uint256 tokenPrice = getTokenPriceInUSD(token);
        return (tokenAmount * tokenPrice) / 1e18;
    }
}
```

---

## 使用示例

### 1. 部署合约

**使用自定义接口版本：**
```solidity
// 以太坊主网 ETH/USD 价格聚合器地址
address ethUsdPriceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

PriceOracle oracle = new PriceOracle(ethUsdPriceFeed);
```

**使用官方库版本（推荐）：**
```solidity
// 以太坊主网 ETH/USD 价格聚合器地址
address ethUsdPriceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

PriceOracleOfficial oracle = new PriceOracleOfficial(ethUsdPriceFeed);

// 获取价格聚合器的详细信息（官方库版本独有功能）
(uint8 decimals, string memory description, uint256 version) = oracle.getEthPriceFeedInfo();
// decimals: 8
// description: "ETH / USD"
// version: 3
```

### 2. 设置 ERC20 代币价格源

```solidity
// USDC/USD 价格聚合器（以太坊主网）
address usdcUsdPriceFeed = 0x8fFfFfd4AfB6115b04Bd6860E2415C89C1C7C4b8;

oracle.setTokenPriceFeed(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, usdcUsdPriceFeed);
```

### 3. 查询价格

```solidity
// 获取 ETH 价格（18 位小数）
uint256 ethPrice = oracle.getEthPriceInUSD();
// 例如：3000500000000000000000 表示 $3000.50

// 获取 USDC 价格
uint256 usdcPrice = oracle.getTokenPriceInUSD(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

// 将 1 ETH 转换为美元
uint256 oneEth = 1e18;
uint256 usdValue = oracle.ethToUSD(oneEth);
```

### 4. 在拍卖合约中使用

**使用自定义接口版本：**
```solidity
contract AuctionWithOracle {
    PriceOracle public oracle;
    
    function getAuctionValueInUSD(uint256 auctionId) public view returns (uint256) {
        Auction memory auction = auctions[auctionId];
        // 将 ETH 出价转换为美元价值
        return oracle.ethToUSD(auction.highestBid);
    }
}
```

**使用官方库版本：**
```solidity
contract AuctionWithOracleOfficial {
    PriceOracleOfficial public oracle;
    
    function getAuctionValueInUSD(uint256 auctionId) public view returns (uint256) {
        Auction memory auction = auctions[auctionId];
        // 将 ETH 出价转换为美元价值
        return oracle.ethToUSD(auction.highestBid);
    }
    
    // 获取价格聚合器信息（官方库版本独有）
    function getOracleInfo() public view returns (string memory) {
        (, string memory description, ) = oracle.getEthPriceFeedInfo();
        return description; // 例如: "ETH / USD"
    }
}
```

---

## 常见价格聚合器地址

### 以太坊主网（Ethereum Mainnet）

| 资产对 | 聚合器地址 |
|--------|-----------|
| ETH/USD | `0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419` |
| BTC/USD | `0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c` |
| USDC/USD | `0x8fFfFfd4AfB6115b04Bd6860E2415C89C1C7C4b8` |
| DAI/USD | `0xAed0c38402a5d19df6E4c03F4E2DceD6E29c1ee9` |
| LINK/USD | `0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c` |

### Sepolia 测试网

| 资产对 | 聚合器地址 |
|--------|-----------|
| ETH/USD | `0x694AA1769357215DE4FAC081bf1f309aDC325306` |
| BTC/USD | `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43` |

**注意：** 价格聚合器地址可能更新，请访问 [Chainlink 官方文档](https://docs.chain.link/data-feeds/price-feeds/addresses) 获取最新地址。

---

## 注意事项

### 1. 价格精度

- Chainlink 价格以 **8 位小数**存储
- 转换为 18 位小数时需要乘以 `1e10`
- 计算时注意避免溢出

### 2. 价格过期检查

- 始终检查价格更新时间
- 设置合理的过期阈值（建议 1 小时）
- 过期的价格可能导致资金损失

### 3. 价格有效性验证

- 检查价格是否大于 0
- 检查 `answeredInRound >= roundId`
- 检查更新时间戳

### 4. Gas 成本

- 每次查询价格需要调用外部合约
- 考虑缓存价格数据（但要注意过期问题）
- 批量查询可以优化 Gas

### 5. 多链部署

- 不同链上的价格聚合器地址不同
- 部署前确认目标链的聚合器地址
- 测试网和主网地址不同

### 6. 价格波动

- 价格可能快速变化
- 考虑使用时间加权平均价格（TWAP）
- 对于大额交易，考虑价格滑点保护

---

## 测试示例

### Foundry 测试

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/PriceOracle.sol";

contract PriceOracleTest is Test {
    PriceOracle public oracle;
    
    // 以太坊主网 ETH/USD 价格聚合器（用于测试）
    address constant ETH_USD_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    
    function setUp() public {
        oracle = new PriceOracle(ETH_USD_FEED);
    }
    
    function testGetEthPrice() public {
        uint256 price = oracle.getEthPriceInUSD();
        assertGt(price, 0, "Price should be greater than 0");
        // 价格应该在合理范围内（例如：$1000 - $10000）
        assertGt(price, 1000e18, "Price too low");
        assertLt(price, 10000e18, "Price too high");
    }
    
    function testEthToUSD() public {
        uint256 oneEth = 1e18;
        uint256 usdValue = oracle.ethToUSD(oneEth);
        assertGt(usdValue, 0, "USD value should be greater than 0");
    }
}
```

---

## 总结

使用 Chainlink 价格预言机的关键点：

1. ✅ **使用标准接口**：`AggregatorV3Interface` 确保兼容性
2. ✅ **验证数据有效性**：检查价格、时间戳、roundId
3. ✅ **处理精度转换**：8 位小数 → 18 位小数
4. ✅ **设置过期阈值**：防止使用过时价格
5. ✅ **灵活配置**：支持多种代币价格查询
6. ✅ **安全第一**：多重检查确保数据可靠性

通过以上实现，你的合约可以安全、可靠地获取链上资产的价格信息！

