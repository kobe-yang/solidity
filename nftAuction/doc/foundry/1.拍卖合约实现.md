## 使用 Foundry 实现一个简单的 NFT 拍卖合约

本文档说明如何在 Foundry 项目中，实现一个支持：

- **创建拍卖**：卖家将某个 NFT 上架拍卖  
- **出价（竞拍）**：允许用原生 ETH 出价（可扩展为 ERC20）  
- **结束拍卖**：拍卖结束后，NFT 转给最高出价者，ETH 转给卖家  

示例代码基于：

- Solidity ^0.8.20  
- OpenZeppelin `ERC721` / `IERC721` / `ReentrancyGuard`  

> 提示：本合约只展示核心逻辑，用于学习示例，生产环境需完善安全与边界检查。

---

## 合约设计要点

- **角色**
  - 卖家（seller）：拥有 NFT 的地址
  - 竞拍者（bidder）：出价的用户
  - 合约（auction contract）：保管 NFT 和竞拍 ETH

- **流程**
  1. 卖家在拍卖合约中创建拍卖（传入 NFT 合约地址、tokenId、起拍价、截止时间）
  2. 卖家先 `approve` 或 `setApprovalForAll`，然后创建拍卖时，NFT 转移到拍卖合约中托管
  3. 任何人可以在拍卖时间内调用 `bid` 出价，出价必须高于当前最高价
  4. 新出价成功后，退回之前最高出价者的 ETH
  5. 到达结束时间后，任何人都可以调用 `endAuction`：
     - 如果有人出价：NFT → 最高出价者，ETH → 卖家  
     - 如果无人出价：NFT 退回给卖家

---

## 拍卖合约示例代码（ETH 出价版）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "openzeppelin/contracts/token/ERC721/IERC721.sol";
import "openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SimpleNftAuction is ReentrancyGuard {
    struct Auction {
        address seller;
        address nftAddress;
        uint256 tokenId;
        uint256 minBid;        // 起拍价
        uint256 endTime;       // 结束时间（时间戳）
        address highestBidder; // 当前最高出价者
        uint256 highestBid;    // 当前最高出价
        bool settled;          // 是否已结算
    }

    uint256 public nextAuctionId;
    mapping(uint256 => Auction) public auctions;

    event AuctionCreated(
        uint256 indexed auctionId,
        address indexed seller,
        address indexed nftAddress,
        uint256 tokenId,
        uint256 minBid,
        uint256 endTime
    );

    event BidPlaced(
        uint256 indexed auctionId,
        address indexed bidder,
        uint256 amount
    );

    event AuctionSettled(
        uint256 indexed auctionId,
        address indexed seller,
        address indexed winner,
        uint256 amount
    );

    /// @notice 创建拍卖（NFT 需要提前 approve 给本合约）
    function createAuction(
        address nftAddress,
        uint256 tokenId,
        uint256 minBid,
        uint256 duration
    ) external returns (uint256 auctionId) {
        require(duration > 0, "Duration must be > 0");

        auctionId = nextAuctionId++;

        // 将 NFT 从卖家转移到拍卖合约托管
        IERC721(nftAddress).transferFrom(msg.sender, address(this), tokenId);

        auctions[auctionId] = Auction({
            seller: msg.sender,
            nftAddress: nftAddress,
            tokenId: tokenId,
            minBid: minBid,
            endTime: block.timestamp + duration,
            highestBidder: address(0),
            highestBid: 0,
            settled: false
        });

        emit AuctionCreated(
            auctionId,
            msg.sender,
            nftAddress,
            tokenId,
            minBid,
            block.timestamp + duration
        );
    }

    /// @notice 出价（使用原生 ETH），必须高于当前最高价
    function bid(uint256 auctionId) external payable nonReentrant {
        Auction storage auction = auctions[auctionId];
        require(auction.seller != address(0), "Auction not found");
        require(block.timestamp < auction.endTime, "Auction ended");

        uint256 currentBid = msg.value;
        require(
            currentBid >= auction.minBid &&
                currentBid > auction.highestBid,
            "Bid too low"
        );

        // 退还上一位最高出价者
        if (auction.highestBidder != address(0)) {
            (bool refundOk, ) = auction.highestBidder.call{
                value: auction.highestBid
            }("");
            require(refundOk, "Refund failed");
        }

        auction.highestBidder = msg.sender;
        auction.highestBid = currentBid;

        emit BidPlaced(auctionId, msg.sender, currentBid);
    }

    /// @notice 结束拍卖：转移 NFT 和 ETH
    function endAuction(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        require(auction.seller != address(0), "Auction not found");
        require(block.timestamp >= auction.endTime, "Auction not yet ended");
        require(!auction.settled, "Already settled");

        auction.settled = true;

        if (auction.highestBidder != address(0)) {
            // 有人出价：NFT -> 最高出价者，ETH -> 卖家
            IERC721(auction.nftAddress).transferFrom(
                address(this),
                auction.highestBidder,
                auction.tokenId
            );

            (bool payoutOk, ) = auction.seller.call{
                value: auction.highestBid
            }("");
            require(payoutOk, "Payout failed");

            emit AuctionSettled(
                auctionId,
                auction.seller,
                auction.highestBidder,
                auction.highestBid
            );
        } else {
            // 无人出价：NFT 退回给卖家
            IERC721(auction.nftAddress).transferFrom(
                address(this),
                auction.seller,
                auction.tokenId
            );

            emit AuctionSettled(
                auctionId,
                auction.seller,
                address(0),
                0
            );
        }
    }
}
```

---

## 与 SimpleNFT 的配合使用示例

假设我们已有一个简单的 `SimpleNFT` 合约（基于 OpenZeppelin `ERC721`），卖家可以：

1. 在 `SimpleNFT` 中铸造 NFT：

   ```solidity
   // 伪代码示例
   uint256 tokenId = simpleNft.mint(seller, "ipfs://token-uri");
   ```

2. 授权拍卖合约操作该 NFT：

   ```solidity
   simpleNft.approve(address(auctionContract), tokenId);
   // 或者
   simpleNft.setApprovalForAll(address(auctionContract), true);
   ```

3. 在拍卖合约中创建拍卖：

   ```solidity
   uint256 auctionId = auctionContract.createAuction(
       address(simpleNft),
       tokenId,
       0.1 ether, // 起拍价
       1 days     // 持续时间
   );
   ```

4. 其他用户通过 `bid(auctionId)` 参与竞拍，结束后调用 `endAuction(auctionId)` 完成结算。

---

## 扩展：使用 ERC20 出价的思路

如果希望使用 **ERC20 代币** 出价，核心变化有：

- `bid` 不再使用 `msg.value`，而是：
  - 要求用户先 `approve` ERC20 给拍卖合约
  - 在 `bid` 中调用 `IERC20(token).transferFrom(bidder, address(this), amount)`
- 结算时：
  - 将 ERC20 代币从合约转给卖家
  - 不再处理原生 ETH

可以在本示例基础上增加一个 `erc20Token` 字段，并切换资金流逻辑即可。

---

## 在 Foundry 中使用本合约

1. 将合约文件保存到 `nft/src/` 目录，例如：

   ```text
   nft/src/SimpleNftAuction.sol
   ```

2. 在 `foundry.toml` 中已配置：

   ```toml
   [profile.default]
   src = "src"
   libs = ["lib"]
   ```

   确保 `openzeppelin-contracts` 已通过 `git submodule` 或 `forge install` 放在 `lib/openzeppelin-contracts` 目录。

3. 编译：

   ```bash
   cd nftAuction/nft
   forge build
   ```

4. 可以在 `test/` 目录编写测试，例如：

   - 测试创建拍卖是否正常托管 NFT  
   - 测试多人出价时最高出价是否更新  
   - 测试 `endAuction` 后 NFT/ETH 是否正确流转

---

## 集成价格预言机的拍卖合约（NftAuctionWithOracle）

### 概述

`NftAuctionWithOracle` 是一个集成了 Chainlink 价格预言机的增强版拍卖合约，支持：

- ✅ **ETH 和 ERC20 代币出价**：支持使用原生 ETH 或任意 ERC20 代币出价
- ✅ **美元价值显示**：所有出价自动转换为美元价值，便于比较
- ✅ **统一价格比较**：不同代币的出价可以公平比较（基于美元价值）
- ✅ **价格预言机集成**：内置 Chainlink 价格预言机功能
- ✅ **单合约部署**：只需部署一个合约即可使用所有功能

### 核心功能

#### 1. 价格预言机功能

合约集成了 `PriceOracleOfficial` 的所有功能：

- 获取 ETH/USD 价格
- 获取 ERC20/USD 价格
- 将 ETH 转换为美元价值
- 将 ERC20 代币转换为美元价值
- 管理价格聚合器配置

#### 2. 拍卖功能增强

**创建拍卖：**
- 起拍价以美元为单位（`minBidUSD`），更直观
- 支持任意 NFT 合约

**出价方式：**
- `bidWithETH()`：使用原生 ETH 出价
- `bidWithERC20()`：使用 ERC20 代币出价
- 所有出价自动转换为美元价值进行比较

**价格比较：**
- 不同代币的出价可以公平比较
- 例如：1 ETH ($3000) vs 3000 USDC ($3000) 可以正确比较

### 合约代码

合约位置：`src/NftAuctionWithOracle.sol`

**主要结构：**

```solidity
struct Auction {
    address seller;
    address nftAddress;
    uint256 tokenId;
    uint256 minBidUSD;      // 起拍价（美元，18 位小数）
    uint256 endTime;
    address highestBidder;
    uint256 highestBid;     // 原始出价金额
    BidType bidType;        // ETH 或 ERC20
    address bidToken;       // ERC20 代币地址（ETH 时为 address(0)）
    bool settled;
}

enum BidType {
    ETH,
    ERC20
}
```

### 使用示例

#### 1. 部署合约

```solidity
// Sepolia ETH/USD 价格聚合器
address ethUsdPriceFeed = 0x694AA1769357215DE4FAC081bf1f309aDC325306;

NftAuctionWithOracle auction = new NftAuctionWithOracle(ethUsdPriceFeed);
```

#### 2. 设置 ERC20 代币价格聚合器

```solidity
// 设置 USDC/USD 价格聚合器（Sepolia）
address usdcToken = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
address usdcUsdPriceFeed = 0xA2F78ab2355fe2f984D808B5CeE7FD6A2bD5F3d5;

auction.setTokenPriceFeed(usdcToken, usdcUsdPriceFeed);
```

#### 3. 创建拍卖（以美元为单位）

```solidity
// 创建拍卖，起拍价 $1000（18 位小数）
uint256 minBidUSD = 1000 * 1e18; // $1000

uint256 auctionId = auction.createAuction(
    nftAddress,
    tokenId,
    minBidUSD,
    7 days  // 持续时间
);
```

#### 4. 使用 ETH 出价

```solidity
// 假设 1 ETH = $3000，出价 0.5 ETH = $1500
auction.bidWithETH{value: 0.5 ether}(auctionId);
```

#### 5. 使用 ERC20 代币出价

```solidity
// 先授权代币
IERC20(usdcToken).approve(address(auction), 2000 * 1e6); // 2000 USDC

// 出价 2000 USDC = $2000
auction.bidWithERC20(auctionId, usdcToken, 2000 * 1e6);
```

#### 6. 查询当前最高出价（美元）

```solidity
// 获取当前最高出价的美元价值
uint256 highestBidUSD = auction.getAuctionHighestBidUSD(auctionId);
// 例如：1500000000000000000000 表示 $1500（18 位小数）
```

#### 7. 结束拍卖

```solidity
// 拍卖结束后，任何人都可以调用
auction.endAuction(auctionId);
// NFT → 最高出价者
// 资金（ETH 或 ERC20）→ 卖家
```

### 价格转换示例

假设当前价格：
- ETH/USD: $3000
- USDC/USD: $1.00

**场景 1：ETH 出价**
```solidity
// 出价 1 ETH
auction.bidWithETH{value: 1 ether}(auctionId);
// 美元价值：1 ETH × $3000 = $3000
```

**场景 2：USDC 出价**
```solidity
// 出价 3000 USDC
auction.bidWithERC20(auctionId, usdcToken, 3000 * 1e6);
// 美元价值：3000 USDC × $1.00 = $3000
```

**结果：** 两个出价的美元价值相同，可以公平比较！

### 优势对比

| 特性 | SimpleNftAuction | NftAuctionWithOracle |
|------|-----------------|---------------------|
| 出价方式 | 仅 ETH | ETH + ERC20 |
| 价格显示 | ETH 数量 | 美元价值 |
| 价格比较 | 仅同种代币 | 跨代币比较 |
| 价格预言机 | 无 | 内置 Chainlink |
| 部署数量 | 1 个合约 | 1 个合约（集成） |

### 部署脚本

创建部署脚本 `script/DeployNftAuctionWithOracle.s.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/NftAuctionWithOracle.sol";

contract DeployNftAuctionWithOracle is Script {
    address constant SEPOLIA_ETH_USD_FEED = 0x694AA1769357215DE4FAC081bf1f309aDC325306;

    function run() external returns (NftAuctionWithOracle) {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address ethUsdPriceFeed = vm.envOr("ETH_USD_PRICE_FEED", SEPOLIA_ETH_USD_FEED);

        vm.startBroadcast(deployerPrivateKey);
        
        NftAuctionWithOracle auction = new NftAuctionWithOracle(ethUsdPriceFeed);
        
        // 可选：设置 ERC20 代币价格聚合器
        // address usdcToken = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
        // address usdcUsdPriceFeed = 0xA2F78ab2355fe2f984D808B5CeE7FD6A2bD5F3d5;
        // auction.setTokenPriceFeed(usdcToken, usdcUsdPriceFeed);
        
        vm.stopBroadcast();
        
        console2.log("NftAuctionWithOracle deployed at:", address(auction));
        return auction;
    }
}
```

### 注意事项

1. **价格过期阈值**：默认 24 小时，适合测试网。主网建议根据实际需求调整
2. **代币精度**：假设所有 ERC20 代币为 18 位小数，USDC 等 6 位小数代币需要转换
3. **价格聚合器**：使用 ERC20 出价前，必须先设置该代币的价格聚合器
4. **Gas 成本**：每次出价会调用价格预言机，产生额外的 Gas 成本

### 扩展建议

1. **支持多代币精度**：处理不同精度的 ERC20 代币（6 位、18 位等）
2. **价格缓存**：缓存价格数据，减少预言机调用
3. **批量查询**：提供批量查询多个拍卖的美元价值
4. **价格历史**：记录出价时的价格，用于审计

---

## 总结

- **SimpleNftAuction**：基础版本，仅支持 ETH 出价，适合学习和简单场景
- **NftAuctionWithOracle**：增强版本，支持 ETH 和 ERC20 出价，集成价格预言机，适合生产环境

根据需求选择合适的版本！

