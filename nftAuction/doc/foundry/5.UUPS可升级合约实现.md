# UUPS 可升级合约实现

本文档介绍如何使用 UUPS（Universal Upgradeable Proxy Standard）代理模式实现 NFT 拍卖合约的可升级功能。

## 一、代理模式对比

| 特性 | UUPS | 透明代理 |
|------|------|----------|
| 升级逻辑位置 | 实现合约中 | 代理合约中 |
| Gas 成本 | 较低 | 较高 |
| 部署复杂度 | 简单 | 复杂 |
| 安全性 | 需要在实现中保护 | 代理自动保护 |
| 推荐场景 | 大多数项目 | 需要额外安全保障 |

**本项目选择 UUPS**：更节省 Gas，部署简单，是 OpenZeppelin 推荐的方式。

## 二、安装依赖

```bash
cd /Users/kobeyang/Desktop/web3/solidity/task/nftAuction/nft

# 安装 OpenZeppelin 可升级合约库
forge install OpenZeppelin/openzeppelin-contracts-upgradeable --no-commit
```

更新 `foundry.toml` 的 remappings：

```toml
remappings = [
  "openzeppelin/=lib/openzeppelin-contracts/",
  "openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
  "forge-std/=lib/forge-std/src/",
  "@chainlink/=lib/chainlink-brownie-contracts/contracts/"
]
```

## 三、可升级合约实现

### 3.1 关键改动

从普通合约改为可升级合约需要：

1. **继承可升级基类**：
   - `Initializable` - 初始化保护
   - `UUPSUpgradeable` - UUPS 升级逻辑
   - `OwnableUpgradeable` - 可升级的权限控制
   - `ReentrancyGuardUpgradeable` - 可升级的重入保护

2. **用 `initialize` 替代 `constructor`**：
   ```solidity
   // 禁用构造函数
   constructor() {
       _disableInitializers();
   }
   
   // 使用初始化函数
   function initialize(address _ethUsdPriceFeed, address _owner) public initializer {
       __Ownable_init(_owner);
       __ReentrancyGuard_init();
       __UUPSUpgradeable_init();
       // ... 其他初始化
   }
   ```

### 3.3 `initialize` 函数详解

#### 为什么需要 `initialize`？

在代理模式中，**实现合约的 `constructor` 不会被代理合约调用**。原因：

```
用户 --> Proxy（存储数据）--delegatecall--> Implementation（只有逻辑）
```

- `constructor` 在部署时执行，初始化的是 **Implementation 合约的存储**
- 但用户通过 Proxy 调用时，数据存储在 **Proxy 合约的存储**
- 所以 `constructor` 初始化的数据对 Proxy 无效

#### `initialize` 什么时候被调用？

**只在首次部署代理时调用一次**，通过部署脚本：

```solidity
// 部署脚本中
bytes memory initData = abi.encodeWithSelector(
    NftAuctionWithOracleUpgradeable.initialize.selector,
    ethUsdPriceFeed,  // 参数1
    owner             // 参数2
);

// 部署代理时，第二个参数就是初始化调用数据
ERC1967Proxy proxy = new ERC1967Proxy(address(implementation), initData);
```

这相当于：部署代理后立即调用 `proxy.initialize(ethUsdPriceFeed, owner)`

#### `initializer` 修饰符的作用

```solidity
function initialize(...) public initializer {
    // ...
}
```

`initializer` 确保此函数**只能被调用一次**，防止：
- 恶意用户重新初始化合约
- 覆盖已有的 owner 或关键配置

#### 流程图

```
首次部署:
┌─────────────────────────────────────────────────────────┐
│ 1. 部署 Implementation 合约                              │
│    - constructor() 执行 _disableInitializers()          │
│    - 禁止在 Implementation 上调用 initialize            │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 部署 Proxy 合约，传入 initData                        │
│    - Proxy 通过 delegatecall 调用 initialize            │
│    - 数据写入 Proxy 的存储                               │
│    - initializer 标记为已初始化                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 用户通过 Proxy 地址交互                               │
│    - 所有调用都通过 Proxy                                │
│    - 再次调用 initialize 会失败（已初始化）              │
└─────────────────────────────────────────────────────────┘

升级时:
┌─────────────────────────────────────────────────────────┐
│ 1. 部署新的 Implementation V2                            │
│ 2. 调用 proxy.upgradeToAndCall(newImpl, "")             │
│    - Proxy 地址不变                                      │
│    - 存储数据保留                                        │
│    - 不需要再调用 initialize（数据已存在）               │
└─────────────────────────────────────────────────────────┘
```

3. **实现升级授权**：
   ```solidity
   function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
   ```

### 3.2 完整合约代码

合约位置：`src/NftAuctionWithOracleUpgradeable.sol`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
// ... 其他 imports

contract NftAuctionWithOracleUpgradeable is 
    Initializable, 
    UUPSUpgradeable, 
    OwnableUpgradeable, 
    ReentrancyGuardUpgradeable 
{
    // 版本号（用于追踪升级）
    uint256 public constant VERSION = 1;
    
    // 状态变量...
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(address _ethUsdPriceFeed, address _owner) public initializer {
        __Ownable_init(_owner);
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();
        
        ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);
        stalePriceThreshold = 3600 * 24;
    }
    
    function _authorizeUpgrade(address) internal override onlyOwner {}
    
    // ... 其他功能函数
}
```

## 四、部署流程

### 4.1 环境变量配置

```bash
export PRIVATE_KEY="0x你的私钥"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/YOUR_ID"
export ETH_USD_PRICE_FEED="0x694AA1769357215DE4FAC081bf1f309aDC325306"
export OWNER_ADDRESS="0x你的地址"  # 可选，默认为部署者
```

### 4.2 部署命令

```bash
cd /Users/kobeyang/Desktop/web3/solidity/task/nftAuction/nft

# ========== 首次部署 ==========
forge script script/DeployNftAuctionUpgradeable.s.sol:DeployNftAuctionUpgradeable \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
# ========== 部署并验证 ==========
forge script script/DeployNftAuctionUpgradeable.s.sol:DeployNftAuctionUpgradeable \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  -vvvv  
  
# ========== 验证合约 ==========
# 获取初始化数据的编码
cast abi-encode "initialize(address,address)" \
  0x694AA1769357215DE4FAC081bf1f309aDC325306 \
  0xfab857c5a4c3047abeed3F5c044f871b8633649d

# 验证代理合约
forge verify-contract \
  0xB8BbC68e2f18304c4e8C77481E90164CBa17428A \
  lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol:ERC1967Proxy \
  --chain sepolia \
  --etherscan-api-key $ETHERSCAN_API_KEY \
  --constructor-args $(cast abi-encode "constructor(address,bytes)" \
    0x53430EA8d0b2b9673eda74119329A4Ab3286d3EA \
    $(cast abi-encode "initialize(address,address)" 0x694AA1769357215DE4FAC081bf1f309aDC325306 0xfab857c5a4c3047abeed3F5c044f871b8633649d))
  
  

# ========== 升级合约 ==========
# 先设置代理地址（首次部署输出的 Proxy 地址）
export PROXY_ADDRESS="0x你的代理合约地址"

forge script script/DeployNftAuctionUpgradeable.s.sol:UpgradeNftAuction \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
```


### 4.3 部署输出示例

```
Implementation deployed at: 0x1234...
Proxy deployed at: 0x5678...

=== Deployment Summary ===
Implementation: 0x1234...
Proxy (use this): 0x5678...
```

**重要**：用户交互时使用 **Proxy 地址**，不是 Implementation 地址。

## 五、升级流程

### 5.1 创建新版本合约

```solidity
// NftAuctionWithOracleUpgradeableV2.sol
contract NftAuctionWithOracleUpgradeableV2 is 
    NftAuctionWithOracleUpgradeable 
{
    uint256 public constant VERSION = 2;
    
    // 新功能
    uint256 public platformFee;
    
    function setPlatformFee(uint256 _fee) external onlyOwner {
        platformFee = _fee;
    }
}
```

### 5.2 执行升级

```bash
export PROXY_ADDRESS="0x5678..."  # 代理合约地址

forge script script/DeployNftAuctionUpgradeable.s.sol:UpgradeNftAuction \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast \
  -vvvv
```

### 5.3 验证升级

```bash
# 检查版本号
cast call $PROXY_ADDRESS "VERSION()(uint256)" --rpc-url $SEPOLIA_RPC_URL

# 检查新功能是否可用
cast call $PROXY_ADDRESS "platformFee()(uint256)" --rpc-url $SEPOLIA_RPC_URL
```

## 六、升级注意事项

### 6.1 存储布局规则

**❌ 禁止操作**：
- 删除已有状态变量
- 更改状态变量顺序
- 更改状态变量类型

**✅ 允许操作**：
- 在末尾添加新状态变量
- 添加新函数
- 修改函数逻辑

### 6.2 存储间隙（推荐）

为未来升级预留存储空间：

```solidity
contract NftAuctionWithOracleUpgradeable {
    // 现有状态变量...
    
    // 预留 50 个存储槽位
    uint256[50] private __gap;
}
```

### 6.3 初始化新变量

升级时如需初始化新变量，使用 `reinitializer`：

```solidity
function initializeV2(uint256 _platformFee) public reinitializer(2) {
    platformFee = _platformFee;
}
```

## 七、架构图

```
用户调用
    │
    ▼
┌─────────────┐
│  ERC1967    │  ◄── 代理合约（存储数据）
│   Proxy     │      地址固定不变
└─────┬───────┘
      │ delegatecall
      ▼
┌─────────────┐
│ Implementation │  ◄── 实现合约（只有逻辑）
│   Contract     │      可以升级替换
└─────────────┘
```

## 八、安全建议

1. **多签控制**：升级权限应由多签钱包控制
2. **时间锁**：添加 Timelock 延迟升级执行
3. **测试充分**：升级前在测试网完整测试
4. **审计**：重大升级需要安全审计
5. **备份**：记录每次升级的实现合约地址

## 九、常见问题

### Q1: 为什么选择 UUPS 而不是透明代理？

UUPS 更省 Gas，升级逻辑在实现合约中，代理合约更轻量。OpenZeppelin 推荐 UUPS。

### Q2: 升级后数据会丢失吗？

不会。数据存储在代理合约中，升级只更换逻辑实现。

### Q3: 如何防止恶意升级？

- 使用 `onlyOwner` 限制升级权限
- 使用多签钱包作为 owner
- 添加 Timelock 机制

### Q4: 可以降级吗？

技术上可以，但不推荐。应该通过新版本修复问题。

